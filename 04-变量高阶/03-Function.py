# coding=utf-8
# 函数就是方法
# 参数-->函数-->返回值
# ---------------------------------------
# 一.多个返回值
# 1.使用元组(),一起返回数据
def measuer():
    """"测量温度和湿度"""
    print ("测量开始..")
    temp = 39
    print ("测量结束..")
    wetness = 50
    # 元组-可以包含多个数据,因此可以使用元组一次返回多个值
    # 如果函数返回的类型是元组,小括号可以省略
    return temp, wetness


# result保存的数据类型同样是元组
result = measuer()
print (result)
# 1.如果要单独的从元组中获取数据,直接result[0](不推荐)
# 2.使用多个变量,一次接受函数的返回结果(推荐)
# 注意,变量的个数应该与元组中元素的个数保持一致
gl_temp, gl_wetness = measuer()
# -----------------------------------------------------
# 二,Python专用交换数据的解法
a = 6
b = 100
# 等号左侧使用多个变量接收元组,等号右侧为元组
a, b = (b, a)
print (a)
print (b)


# ----------------------------------------------------------------------------
# 三,不可变和可变的参数
def demo(num):
    print ("函数内部的代码")
    # 在函数内部,针对参数(可变与不可变都一样)使用赋值语句等于(new一个变量),不会修改到外部实参变量
    # 且全局变量与局部变量中,以局部变量为准
    num = 100
    print (num)
    print ("函数执行完成")


gl_num = 99
demo(gl_num)
print (gl_num)


# -------------------------------------------------------------------------
# 四,可变类型的参数,如果在函数内使用了方法对其进行修改会影响全局变量
def mutable(num_list):
    # 这里使用到了列表的extend方法对列表进行增加数据,在原列表中添加了数据
    num_list.extend([1, 2, 3])
    print (num_list)


gl_list = [6, 7, 8]
mutable(gl_list)
print (gl_list)


# -------------------------------------------------------------------------------------------------
# 五,列表变量使用+=不会做相加再赋值的操作
# num_list=num_list+num_list(这是数学参数要用的)
# 本质上是在调用列表的extend方法即:
# num_list.extend(num_list)所以局部变量会影响全局变量(而不是修改变量的引用)
# ------------------------------------------------------------------------------
# 六,函数的缺省参数(即设置默认值)
# 缺省参数的注意事项:
# 1,缺省参数必须定义在参数列表的末尾
def print_info(name, title, gender=True):
    print (name, title, gender)


print_info("xiaoming", "1")
# 如果要修改默认的缺省值,就需要在调用的时候通过参数名全部添加进来
print_info("xiaoli", "2", gender=False)


# -----------------------------------------------------------------------------------
# 七,多值参数
# 让一个函数能够处理多个不确定的参数
# *元组:*args|--|**字典:**kwargs,
def demo(num, *nums, **person):
    print (num)
    print (nums)
    print (person)


# 调用多值函数(python会自动判断与封装对应的参数,根据顺序,只要函数定义了,在调用的时候传参就能接收)
demo(1, 2, 3, 4, 5, name="小明", age=18)


# -----------------------------------------------------------------------------------------------
# 八,使用多值参数接收元组或使用()进一步包装参数直接接收元组
def sum_numbers(*args):
    num = 0
    print (args)
    # 循环遍历接收的元组
    for n in args:
        # 将传入的元组的值挨个相加
        num += n
    return num


result = sum_numbers(1, 2, 3, 4, 5)
print (result)


# ----------------------------------------------------------------------------------------------------
# 九,元组和字典的拆包:简化元组变量与字典变量的传递
# 调用函数的时候*参数:元组|**参数:字典
def demo(*args, **kwargs):
    print (args)
    print (kwargs)


# 定义元组与字典的全局变量,而不是直接传入参数
gl_nums = (1, 2, 3)
gl_dict = {"name": "小明", "age": 18}
# 直接传入参数是可以识别的,如:(1,2,3,"name": "小明", "age": 18)
# 但是如果想用变量名的话,需要使用拆包语法告诉Python我们的参数变量是神马
# 否则会当做元组传入
demo(*gl_nums, **gl_dict)


# -----------------------------------------------------------------------------------------------------------
# 十,递归:我调我自己(主要在处理不确定的循环条件,比如:遍历整个文件目录的结构)
# 当参数满足一个条件时,函数不再执行,通常被称为递归的出口,如果没有则会出现死循环
def sum_numbser(num):
    print (num)
    # 递归的出口,当参数满足某个条件时不再执行
    # 当num等于1的时候就会退出(有点像循环条件)(不增加出口会出现死循环)
    if num == 1:
        # 当满足条件执行return,也就是上次调用递归函数的地方,如果上层函数后面没有内容,再返回上上层,以此类推
        # 直到最外层,整个函数执行完即结束
        # -->1-->2-->3(return)
        # 3-->2-->1
        return
    # 自己调自己,(有点像循环体)
    sum_numbser(num - 1)


# 调用递归函数
sum_numbser(3)


# -------------------------------------------------------------------------------
# 通过递归定义1+2+3+..+num的结果
def sum_numbser(num):
    # 1.定义递归函数的出口(可以返回归来定义出口)
    if num == 1:
        # 返回1
        return 1

    # 2.数字的累加num+(1...num-1)
    temp = sum_numbser(num - 1)
    # 累加这一步是在递归返回的时候进行的
    return num + temp


result1 = sum_numbser(15)
print (result1)
